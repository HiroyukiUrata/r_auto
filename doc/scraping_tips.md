# 動的Webページのスクレイピングにおける高度なテクニック

このドキュメントは、楽天ROOMのようなJavaScriptで動的にコンテンツが生成・配置されるWebサイト（特にMasonryレイアウト）をPlaywrightで安定してスクレイピングするためのノウハウをまとめたものです。

## 課題

動的なWebページでは、以下のような問題が発生しがちです。

1.  **DOM順序と視覚的順序の不一致**:
    -   複数カラムのレイアウト（Masonryレイアウトなど）では、HTMLソースコード上の要素の順序（DOM順序）と、画面に表示される順序（視覚的順序）が一致しません。
    -   このため、`locator.first` や `locator.all()` で取得した要素の順序が、見た目と異なり、処理順序が狂う原因となります。

2.  **要素の遅延読み込みと描画**:
    -   ページを開いた直後やスクロール後、JavaScriptが走り、要素が非同期で描画されます。
    -   Playwrightのスクリプトが描画完了より先に要素を探しに行くと、要素が見つからなかったり、不完全な状態の要素を取得してしまったりします。

3.  **無限スクロール**:
    -   ページの最下部までスクロールすると、新しいコンテンツが読み込まれます。
    -   この読み込み完了を確実に待機する方法が必要です。単純な時間待機（`time.sleep`）では、ネットワーク状況によって失敗しやすくなります。

## 解決策

これらの問題を解決するために、`test_scripts/utils/masonry_scraper.py` に実装された `MasonryScraper` クラスでは、以下のテクニックを組み合わせています。

### 1. 視覚的な位置情報に基づく要素の特定とソート

DOM順序に依存せず、見た目通りの順序で要素を処理するための最も確実な方法です。

-   **`locator.all()` で全候補を取得**: まず、対象となりうるすべてのカード要素を `locator.all()` で取得します。
-   **`is_visible()` でフィルタリング**: 取得した要素の中から、実際に画面に表示されているものだけを `is_visible()` で絞り込みます。
-   **`bounding_box()` で位置情報を取得**: 各要素の画面上の位置とサイズ（x, y, width, height）を `bounding_box()` で取得します。
-   **Y座標→X座標の順でソート**: 取得した位置情報を使い、まずY座標（上から下へ）、次にX座標（左から右へ）の優先順位でリストをソートします。これにより、視覚的な表示順序が完全に再現されます。

### 2. 意図的な待機による描画の安定化

ページの初期読み込み後、JavaScriptによるレイアウトの再配置が完了するのを待つために、意図的な短い待機時間を設けます。

-   `page.wait_for_timeout(2000)`: 最初の要素が表示された後、さらに2秒間待機します。これにより、Masonryレイアウトの計算と再描画が完了し、すべての要素が正しい位置に配置されるのを待ちます。

### 3. ローディングスピナーを利用した確実な無限スクロール待機

固定時間の待機ではなく、ページの読み込み状態を示すUI要素（ローディングスピナー）を監視することで、無限スクロールを安定させます。

-   **スクロール**: `page.evaluate("window.scrollTo(0, document.body.scrollHeight)")` でページの最下部までスクロールします。
-   **スピナーの出現を待つ**: `locator(spinner).wait_for(state="visible")` で、ローディングスピナーが表示されるのを待ちます。スクロールしてもスピナーがすぐに出ない場合があるため、短い間隔で数回スクロールを繰り返すリトライ処理も有効です。
-   **スピナーの消失を待つ**: `locator(spinner).wait_for(state="hidden")` で、データの読み込みが完了し、スピナーが非表示になるのを待ちます。

これらのテクニックを組み合わせることで、複雑で動的なWebページに対しても、安定したスクレイピング処理を実装することが可能になります。