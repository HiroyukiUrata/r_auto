# エンゲージメント関連ロジック仕様書

このドキュメントは、お知らせ解析からユーザーへのエンゲージメント（いいね返し・コメント返し）に至るまでの一連のロジックと条件を整理したものです。

## 登場する主要タスク

| タスク名 | 実行ファイル | 役割 |
| :--- | :--- | :--- |
| **お知らせ解析** | `notification-analyzer` | ROOMのお知らせページを解析し、ユーザーからのアクション（いいね、フォロー等）をDBに記録する。 |
| **AIコメント作成** | `create-ai-comment` | DBの情報に基づき、AI (Gemini) を使ってユーザーへの返信コメントを生成・保存する。 |
| **エンゲージメント実行** | `engage-user` | DBから対象ユーザーを取得し、「いいね返し」や「コメント返し」を実際に行う。 |
| **古いアクションのコミット** | `commit-stale-actions` | 24時間以上エンゲージメントが実行されなかったユーザーのアクションを「スキップ」扱いとして処理する。 |

---

## データの流れとタイムスタンプの役割

`user_engagement` テーブルには、ユーザーのアクションを追跡するための複数のタイムスタンプが存在します。

| カラム名 | 役割 | 更新タイミング |
| :--- | :--- | :--- |
| `recent_action_timestamp` | **「今回の分析セッション」**で検知された最新アクション時刻。 | `notification-analyzer` 実行のたびに、その分析範囲内で最新の時刻で上書きされる。 |
| `latest_action_timestamp` | **「過去すべての」**アクションの中で最も新しい時刻。 | `notification-analyzer` 実行時に、`recent_action_timestamp` と比較され、より新しい方で更新される。 |
| `ai_prompt_updated_at` | AIに渡すための状況説明文 (`ai_prompt_message`) が更新された時刻。 | `notification-analyzer` 実行時に、新しいアクションが検知されると更新される。 |
| `comment_generated_at` | AIがコメントを生成した時刻。 | `create-ai-comment` 実行時に更新される。 |
| `last_commented_at` | **実際に**コメントを投稿した時刻。 | `engage-user` 実行時にコメント投稿が成功すると更新される。 |

---

## 各タスクの実行条件

### 1. お知らせ解析 (`notification-analyzer`)

- **実行トリガー**: スケジュールまたは手動実行。
- **解析範囲**:
  - DBに記録されている `latest_action_timestamp` の最新時刻。
  - または、ユーザーが指定した時間（例: 12時間前）。
  - 上記のうち、**より新しい方**を基準に、それ以降の通知を解析対象とする。
- **主な処理**:
  1. お知らせページをスクロールし、基準時刻より新しい通知をすべて収集する。
  2. ユーザーごとにアクションを集計し、`recent_like_count` などを計算する。
  3. `recent_action_timestamp` と `latest_action_timestamp` を更新する。
  4. ユーザーの状況（フォロー関係、いいね数など）をまとめた `ai_prompt_message` を生成し、`ai_prompt_updated_at` と共にDBを更新する。
  5. 最後に、30日以上 `latest_action_timestamp` が更新されていない古いユーザー情報をDBから削除する (`cleanup_old_user_engagements`)。

### 2. AIコメント作成 (`create-ai-comment`)

- **実行トリガー**: `notification-analyzer` のフロー完了後、または手動実行。
- **対象ユーザーの条件**:
  - `ai_prompt_message` が存在する。
  - **かつ**、以下のいずれかを満たす。
    - `comment_generated_at` が `NULL` （まだ一度もコメントが生成されていない）。
    - `ai_prompt_updated_at` > `comment_generated_at` （最後にコメントを生成した後、新しいアクションがあった）。
- **主な処理**:
  1. 対象ユーザーの `ai_prompt_message` を元に、Gemini APIを呼び出してコメント本文を生成する。
  2. 生成されたコメント (`comment_text`) と生成時刻 (`comment_generated_at`) をDBに保存する。

### 3. エンゲージメント実行 (`engage-user`)

このタスクは、コメント管理画面から手動で実行されます。

#### 3.1. 対象ユーザーの選定

コメント管理画面に表示されるユーザーは、以下のいずれかの条件を満たしています。

| 対象 | 条件 | UIアイコン |
| :--- | :--- | :--- |
| **コメント対象** | ① **新規**: 未コメントで、今回のいいねが **3件以上**。<br>② **再コメント**: 最終コメントから **3日以上経過** し、かつ今回のいいねが **5件以上**。 | 💬 |
| **いいね返しのみ対象** | コメント済みだが、再コメントの条件を満たさず、今回のいいねが **3件以上**。 | ❤️ |

#### 3.2. いいね返し (`_like_back`)

- **実行条件**: `recent_like_count` が1件以上ある。
- **実行内容**:
  - ユーザーのROOMにアクセスし、最大5件まで「いいね」を返す。
  - 一度「いいね」した投稿は画面から非表示にし、同じ投稿に再度いいねしないようにする。

#### 3.3. コメント返し (`_post_comment`)

- **実行条件**:
  - `comment_text` がDBに存在する。
  - **かつ**、以下のいずれかを満たす。
    - `last_commented_at` が `NULL` （新規コメント）。
    - `comment_generated_at` > `last_commented_at` （最後に投稿した後、新しいコメントが生成されている）。
- **実行内容**:
  1. ユーザーのROOMページをリロードする（いいね返しで非表示になった投稿を再表示するため）。
  2. 投稿の中からコメント数が最も多いものを探し、その詳細ページに遷移する。
  3. DBから取得した `comment_text` を入力し、投稿する。

#### 3.4. アクションのコミット (`commit_user_actions`)

- **実行条件**: いいね返し、またはコメント返しが1件でも成功した場合。
- **実行内容**:
  - `recent_*_count` を累計の `like_count` などに加算し、`recent_*_count` を0にリセットする。
  - コメント投稿が成功した場合、`last_commented_at` を現在の時刻で更新する。

---

## UI (コメント管理画面) の表示ロジック

- **アイコン (💬/❤️)**: 上記「3.1. 対象ユーザーの選定」の条件に基づいて表示される。
- **古いコメントのグレーアウト**: `comment_generated_at` <= `last_commented_at` の場合、そのコメントは「投稿済み」と判断され、半透明で表示される。
- **検索機能**: 「全ユーザー表示」がONの時のみ表示され、ユーザー名での部分一致検索が可能。

---

## 補足: なぜ `latest_action_timestamp` が重要か？

古いユーザー情報を削除する際の基準として `latest_action_timestamp` を使用しています。これにより、**継続的にアクションをしてくれる優良なユーザーの情報（累計いいね数など）が、分析セッションをまたいでも保持され続けます。**

もし `recent_action_timestamp` を基準にすると、しばらくアクションがなかっただけで、過去に多くの交流があったユーザーの情報も削除されてしまうリスクがあります。